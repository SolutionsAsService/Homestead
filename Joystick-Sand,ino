#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_LEDBackpack.h>

// Create 8x8 matrix object
Adafruit_8x8matrix matrix = Adafruit_8x8matrix();

// Joystick pins
const int joyX = A0;
const int joyY = A1;

// Deadzone for joystick
const int DEADZONE_LOW = 400;
const int DEADZONE_HIGH = 600;

// Sand map: 8x8 array
byte sand[8] = {
  0b00011000,
  0b00011000,
  0b00011000,
  0b00011000,
  0b00011000,
  0b00011000,
  0b00011000,
  0b00011000
};

// Time tracking for smoother animation
unsigned long lastMoveTime = 0;
const unsigned long moveInterval = 150; // ms

void setup() {
  Serial.begin(9600);  // Serial debugging
  pinMode(LED_BUILTIN, OUTPUT);  // Onboard LED

  // Blink onboard LED 3 times to indicate sketch upload success
  blinkOnboardLED(3, 200);

  matrix.begin(0x70);  // Default I2C address
  matrix.clear();
  matrix.writeDisplay();
  pinMode(joyX, INPUT);
  pinMode(joyY, INPUT);
}

// Blink function: count = number of blinks, delayMs = blink speed
void blinkOnboardLED(int count, int delayMs) {
  for (int i = 0; i < count; i++) {
    digitalWrite(LED_BUILTIN, HIGH);
    delay(delayMs);
    digitalWrite(LED_BUILTIN, LOW);
    delay(delayMs);
  }
}

void shiftSandX(int dir) {
  for (int i = 0; i < 8; i++) {
    if (dir > 0) {
      byte msb = (sand[i] & 0b10000000) >> 7; // Save bit for wraparound
      sand[i] = (sand[i] << 1) | msb;         // Shift left with wrap
    } else if (dir < 0) {
      byte lsb = sand[i] & 0b00000001;        // Save bit for wraparound
      sand[i] = (sand[i] >> 1) | (lsb << 7);  // Shift right with wrap
    }
  }
}

void shiftSandY(int dir) {
  if (dir > 0) { // Down
    byte lastRow = sand[7];
    for (int i = 7; i > 0; i--) sand[i] = sand[i - 1];
    sand[0] = lastRow; // Wrap top row
  } else if (dir < 0) { // Up
    byte firstRow = sand[0];
    for (int i = 0; i < 7; i++) sand[i] = sand[i + 1];
    sand[7] = firstRow; // Wrap bottom row
  }
}

void loop() {
  int xVal = analogRead(joyX); // 0-1023
  int yVal = analogRead(joyY);

  int xDir = 0;
  int yDir = 0;

  // Determine joystick direction with deadzone
  if (xVal < DEADZONE_LOW) xDir = -1;
  else if (xVal > DEADZONE_HIGH) xDir = 1;

  if (yVal < DEADZONE_LOW) yDir = -1;
  else if (yVal > DEADZONE_HIGH) yDir = 1;

  // Debug joystick readings
  Serial.print("X: "); Serial.print(xVal);
  Serial.print(" | Y: "); Serial.print(yVal);
  Serial.print(" | xDir: "); Serial.print(xDir);
  Serial.print(" | yDir: "); Serial.println(yDir);

  // Move sand at intervals
  if (millis() - lastMoveTime > moveInterval) {
    if (xDir != 0) shiftSandX(xDir);
    if (yDir != 0) shiftSandY(yDir);
    lastMoveTime = millis();
  }

  // Display sand
  matrix.clear();
  for (int row = 0; row < 8; row++) {
    for (int col = 0; col < 8; col++) {
      if (sand[row] & (1 << col)) matrix.drawPixel(col, row, LED_ON);
    }
  }
  matrix.writeDisplay();
}
